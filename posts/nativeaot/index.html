<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D;--font-size:17.5px}</style><title>NativeAOT in .NET: Harder, Better, Faster, Stronger</title>
<meta name=description content="A reflection on using NativeAOT"><meta name=keywords content='blog'><meta property="og:url" content="https://actuallava.com/posts/nativeaot/"><meta property="og:type" content="website"><meta property="og:title" content="NativeAOT in .NET: Harder, Better, Faster, Stronger"><meta property="og:description" content="A reflection on using NativeAOT"><meta property="og:image" content="https://actuallava.com/files/profilepic.png"><meta property="og:image:secure_url" content="https://actuallava.com/files/profilepic.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="NativeAOT in .NET: Harder, Better, Faster, Stronger"><meta name=twitter:description content="A reflection on using NativeAOT"><meta property="twitter:domain" content="https://actuallava.com/posts/nativeaot/"><meta property="twitter:url" content="https://actuallava.com/posts/nativeaot/"><meta name=twitter:image content="https://actuallava.com/files/profilepic.png"><link rel=canonical href=https://actuallava.com/posts/nativeaot/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.3eb19cb61dde9e37b9522867f3e024aeb68e26ab8e03252e46e365abcb19acf7.js integrity="sha256-PrGcth3enje5Uihn8+AkrraOJquOAyUuRuNlq8sZrPc="></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=nav-links><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=back-home style=margin-top:20px><a href=/>← Back to Home</a></div><div class=post-header-section><h1>NativeAOT in .NET: Harder, Better, Faster, Stronger</h1><small role=doc-subtitle>A reflection on using NativeAOT</small><p class=post-date>November 3, 2024</p><ul class=post-tags><li class=post-tag><a href=https://actuallava.com/tags/blog>blog</a></li></ul></div><div class=post-content><h1 id=nativeaot-in-net-harder-better-faster-stronger>NativeAOT in .NET: Harder, Better, Faster, Stronger</h1><p>Over the past few months, I’ve been diving (sinking?) deep into the world of .NET performance optimizations as part of trying to write better cloud services with less hassle. &ldquo;Switch to Go! Or Rust!&rdquo; - I hear you.<br>But now hear me out:<br>In this post, I&rsquo;ll share my personal experiences and practical tips on using NativeAOT to achieve rapid startup times and a smaller memory footprint in .NET applications—without any hype, just what worked for me, and all without having to leave the comforting embrace of Satya Nadella (CEO, Microsoft).</p><hr><h2 id=what-i-learned-about-nativeaot>What I Learned About NativeAOT</h2><p>At its core, NativeAOT takes your managed code and compiles it ahead-of-time (AOT) into <strong>native machine code</strong>. This approach means that, unlike the usual Just-In-Time (JIT) compilation, your code is already optimized for the target platform when it starts up. Here’s what that translated to in my experiments:</p><ul><li><strong>Instant Startup:</strong> By eliminating the need for JIT, my applications were ready to go almost immediately—something especially noticeable during development and in serverless deployments.</li><li><strong>Lean Memory Usage:</strong> Since only the code I actually needed was compiled into the binary, the overall memory footprint was significantly lower. This was a nice bonus when working with resource-constrained dev environments<br>(My trusted Raspberry Pi).</li></ul><hr><h2 id=the-technical-bits-without-the-jargon-overload>The Technical Bits (Without the Jargon Overload)</h2><h3 id=1-bye-jit-delays>1. <strong>Bye JIT Delays</strong></h3><p>I used to wait a few extra moments for the JIT compiler to kick in every time I started my application. With NativeAOT, those delays just disappeared. The result? A much snappier response time, which made a big difference in my local development cycles. That said, it’s worth noting that JIT can sometimes achieve better <strong>peak performance</strong> by dynamically optimizing hot paths at runtime, so NativeAOT trades runtime flexibility for faster startup.</p><p>However, where this shines practically is in scenarios where startup time is more critical than peak performance-<br>Such as in game servers we want to scale up and down quickly based on demand.</p><h3 id=2-smart-code-trimming>2. <strong>Smart Code Trimming</strong></h3><p>One of the more neat aspects of NativeAOT is how it prunes away unused code:</p><ul><li><strong>Trimming in Action:</strong> The compilation process analyzes your code and trims out what isn’t necessary. In my tests, this not only reduced the size of the executable but also helped in cutting down the memory usage.</li><li><strong>Lean, Mean Binaries:</strong> The final binaries felt much more streamlined, which is a relief when every megabyte counts. Keep in mind, though, that self-contained NativeAOT binaries can still be larger than framework-dependent deployments because they include necessary runtime components.</li></ul><h3 id=3-self-contained-deployment>3. <strong>Self-Contained Deployment</strong></h3><p>For me, one of the biggest advantages was that NativeAOT packages everything needed into a single binary (I know, Docker this, Docker that, but bear with me):</p><ul><li><p><strong>No Hidden Dependencies:</strong> There’s no need to worry about installing the right version of .NET on every machine where the app runs.</p></li><li><p><strong>Simplified Distribution:</strong> This self-containment is particularly handy for deployment scenarios where managing dependencies can become a headache.</p><p>Remember when games used to distribute their dedicated server executable for players to host themselves?<br>Pepperidge Farm remembers.</p></li></ul><hr><h2 id=a-practical-guide-to-integrating-nativeaot>A Practical Guide to Integrating NativeAOT</h2><p>I found that getting started with NativeAOT was surprisingly straightforward. Here’s how I set it up in one of my .NET projects:</p><ol><li><p><strong>Update the Project File:</strong></p><p>I added a few properties in my project file to enable AOT compilation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;PropertyGroup&gt;</span>
</span></span><span class=line><span class=cl>  <span class=c>&lt;!-- Enable AOT compilation --&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;PublishAot&gt;</span>true<span class=nt>&lt;/PublishAot&gt;</span>
</span></span><span class=line><span class=cl>  <span class=c>&lt;!-- Optionally, trim the output for a smaller binary --&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;PublishTrimmed&gt;</span>true<span class=nt>&lt;/PublishTrimmed&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/PropertyGroup&gt;</span>
</span></span></code></pre></div><p>Note: <code>&lt;PublishTrimmed></code> is optional but recommended for reducing binary size.</p></li><li><p><strong>Publish the Application:</strong></p><p>Using a simple publish command, I generated a native binary for my target platform. NativeAOT requires <strong>platform-specific compilation</strong>, so make sure to specify the correct runtime identifier (RID):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>dotnet publish -r win-x64 -c Release
</span></span></code></pre></div><p>For cross-platform builds, you’ll need separate publish commands for each target (e.g., <code>linux-x64</code>, <code>osx-arm64</code>).</p></li></ol><p>This process produced a native executable that performed exceptionally well in my tests. It was a simple yet effective way to see tangible improvements without a complete overhaul of my workflow (and I still haven&rsquo;t learned Rust.. Joke&rsquo;s on me).</p><hr><h2 id=real-world-performance>Real-World Performance</h2><p>In my experiments with <strong>console apps and microservices</strong>, I observed some very encouraging numbers:</p><ul><li><strong>Startup Time:</strong> My NativeAOT-compiled apps started almost instantly—sometimes in less than 10 milliseconds for a basic TCP server. This was a stark contrast to the slight lag I experienced with JIT-compiled versions.</li><li><strong>Memory Footprint:</strong> By stripping away unnecessary code and avoiding the JIT overhead, I consistently saw a reduction in memory usage, which was especially beneficial for my little Raspberry Pi, and also for my wallet in the long run.</li></ul><hr><h2 id=practical-considerations>Practical Considerations</h2><p>While I’ve had a positive experience with NativeAOT, there are a few things to keep in mind:</p><ul><li><strong>Reflection and Dynamic Code:</strong> If your project relies heavily on reflection or dynamic code generation, you might need to provide additional configuration (e.g., <code>rd.xml</code> files or <code>[DynamicDependency]</code> attributes) to prevent important code from being trimmed away.</li><li><strong>Platform Compatibility:</strong> Make sure your target platforms and dependencies fully support NativeAOT. I encountered a few hiccups early on, but most issues were resolved by consulting the latest <a href=https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/>.NET NativeAOT documentation</a>. Note that support for macOS ARM64 and some Linux distributions is still evolving.</li><li><strong>Debugging:</strong> Debugging native binaries can be quite a bit more challenging compared to JIT-compiled apps because of the reduced runtime info. I found there are tools like <strong>WinDbg</strong> (Windows) or <strong>lldb</strong> (Linux/macOS) that can help, but be prepared for a slightly different debugging experience.. Or just publish JIT until you&rsquo;re ready to ship a release.</li></ul><hr><h2 id=wrapping-up>Wrapping Up</h2><p>Honestly, is this all that interesting?<br>Maybe not.<br>But when it comes to deploying on scale, especially as a solo developer or in a small team, shaving off a few milliseconds here and there can make a big difference cost-wise. Does this somehow make C# and .NET more appealing for high performance cloud-native development compared to Go, Rust or other modern languages? No, and if I rage-baited you into reading this far, I apologize.</p></div><div class=prev-next></div><div class=back-home style=margin-top:20px><a href=/>← Back to Home</a></div></div></main><footer class=footer><span>&copy; 2024 Actual Lava</span></footer></body></html>